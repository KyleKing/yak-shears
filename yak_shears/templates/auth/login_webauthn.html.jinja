{% extends "base.html.jinja" %}

{% block title %}Login{% endblock %}
{% block header %}Login{% endblock %}

{% block content %}
<div class="form-field">
    <label for="username">Username</label>
    <input type="text" id="username" name="username" value="{{ username }}" disabled>
</div>
<div class="form-field">
    <button id="login-button">Login with WebAuthn</button>
</div>
<div id="error-message" class="error"></div>
<a href="/home" class="back-link">Back to Home</a>
{% endblock %}

{% block scripts %}
<script>
    // Store WebAuthn options
    const webAuthnOptions = {{ client_options|tojson }};

    document.getElementById('login-button').addEventListener('click', async () => {
        try {
            // Get options for WebAuthn
            const publicKeyOptions = {
                challenge: base64ToArrayBuffer(webAuthnOptions.challenge),
                timeout: webAuthnOptions.timeout,
                rpId: webAuthnOptions.rpId,
                userVerification: webAuthnOptions.userVerification,
                allowCredentials: webAuthnOptions.allowCredentials.map(cred => ({
                    id: base64ToArrayBuffer(cred.id),
                    type: cred.type,
                    transports: cred.transports,
                })),
            };

            // Request credential from authenticator
            const credential = await navigator.credentials.get({
                publicKey: publicKeyOptions
            });

            // Prepare credential for server
            const credentialForServer = {
                id: arrayBufferToBase64(credential.rawId),
                rawId: arrayBufferToBase64(credential.rawId),
                type: credential.type,
                response: {
                    authenticatorData: arrayBufferToBase64(credential.response.authenticatorData),
                    clientDataJSON: arrayBufferToBase64(credential.response.clientDataJSON),
                    signature: arrayBufferToBase64(credential.response.signature),
                    userHandle: credential.response.userHandle ?
                        arrayBufferToBase64(credential.response.userHandle) : null,
                },
            };

            // Send credential to server for verification
            const response = await fetch('/auth/verify_login', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    username: '{{ username }}',
                    credential: credentialForServer,
                }),
            });

            if (response.ok) {
                // Redirect to home page on success
                window.location.href = '/home';
            } else {
                const data = await response.json();
                document.getElementById('error-message').textContent =
                    data.error || 'Authentication failed';
            }
        } catch (error) {
            console.error('WebAuthn error:', error);
            document.getElementById('error-message').textContent =
                'WebAuthn error: ' + error.message;
        }
    });

    // Base64 utility functions
    function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes;
    }

    function arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }
</script>
{% endblock %}
